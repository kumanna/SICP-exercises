;; Uses doubly linked lists. May not be the best implementation
(define (make-node value prev next)
  (cons (cons value prev) next))

(define (node-value node)
  (car (car node)))

(define (next-node node)
  (cdr node))

(define (prev-node node)
  (cdr (car node)))

(define (set-node-value! node value)
  (set-car! (car node) value))

(define (set-node-next! node next)
  (set-cdr! node next))

(define (set-node-prev! node prev)
  (set-cdr! (car node) prev))

(define (insert-at-end! node value)
  (if (not (null? (next-node node)))
      (error "INSERT-AT-END! called at non-end node!")
      (let ((new-node (make-node value node '())))
	(set-node-next! node new-node) new-node)))

(define (insert-at-begin! node value)
  (if (not (null? (prev-node node)))
      (error "INSERT-AT-BEGIN! called at non-begin node!")
      (let ((new-node (make-node value '() node)))
	(set-node-prev! node new-node) new-node)))


(define (make-deque) (cons '() '()))

(define (front-ptr deque) (car deque))
(define (rear-ptr deque) (cdr deque))
(define (set-front-ptr! deque v) (set-car! deque v))
(define (set-rear-ptr! deque v) (set-cdr! deque v))
(define (empty-deque? deque) (null? (front-ptr deque)))

(define (front-deque deque)
  (if (empty-deque? deque)
      (error "FRONT-DEQUE called on empty deque!")
      (car (front-ptr deque))))

(define (rear-deque deque)
  (if (empty-deque? deque)
      (error "REAR-DEQUE called on empty deque!")
      (car (rear-ptr deque))))

(define (insert-deque-at-end! deque value)
  (if (empty-deque? deque)
      (let ((new-item (make-node value '() '())))
	(set-front-ptr! deque new-item)
	(set-rear-ptr! deque new-item))
      (let ((new-item (insert-at-end! (rear-ptr deque) value)))
	(set-rear-ptr! deque new-item))) deque)

(define (insert-deque-at-begin! deque value)
  (if (empty-deque? deque)
      (let ((new-item (make-node value '() '())))
	(set-front-ptr! deque new-item)
	(set-rear-ptr! deque new-item))
      (let ((new-item (insert-at-begin! (front-ptr deque) value)))
	(set-front-ptr! deque new-item))) deque)

(define (print-deque deque)
  (define (print-deque-iter node)
    (display (node-value node))
    (display " ")
    (if (not (null? (next-node node)))
	(print-deque-iter (next-node node))))
  (if (not (empty-deque? deque))
      (print-deque-iter (front-ptr deque)))
  (newline))

(define (delete-end! deque)
  (if (empty-deque? deque)
      (error "DELETE-END! called on empty deque!")
      (if (eq? (front-ptr deque)
	       (rear-ptr deque))
	  (begin (set-car! deque '()) (set-cdr! deque '()))
	  (let ((new-last-node (prev-node (rear-ptr deque))))
	    (set-node-next! new-last-node '())
	    (set-rear-ptr! deque new-last-node)))))

(define (delete-begin! deque)
  (if (empty-deque? deque)
      (error "DELETE-BEGIN! called on empty deque!")
      (if (eq? (front-ptr deque)
	       (rear-ptr deque))
	  (begin (set-car! deque '()) (set-cdr! deque '()))
	  (let ((new-first-node (next-node (front-ptr deque))))
	    (set-node-prev! new-first-node '())
	    (set-front-ptr! deque new-first-node)))))

(define dq (make-deque))
(insert-deque-at-begin! dq 1)
(insert-deque-at-begin! dq 2)
(insert-deque-at-begin! dq 3)
(insert-deque-at-end! dq 4)
(insert-deque-at-end! dq 5)
(insert-deque-at-end! dq 6)
(print-deque dq)
(delete-begin! dq)
(print-deque dq)
(delete-end! dq)
(print-deque dq)
(delete-begin! dq)
(print-deque dq)
(delete-end! dq)
(print-deque dq)
(delete-begin! dq)
(print-deque dq)
(delete-end! dq)
(print-deque dq)
